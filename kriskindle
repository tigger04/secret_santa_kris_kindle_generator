#!/usr/bin/env bash

#shellcheck source=helper.sh
. helper.sh

set -e
unset arg_generate_stdout arg_generate_file arg_input_file arg_tests

function usage {
	 cat <<eom
    Usage: $(basename "$0") [OPTION]...

    -g         generate example input
    -G         generate example input to file 
    -i <FILE>  location of input file [default: STDIN]
    -h         display help
eom

}

while getopts "Ggi:ht" optKey; do
	 case "$optKey" in
        g)
            arg_generate_stdout=true
            ;;
		  G)
			   arg_generate_file=true
			   ;;
		  i)
            arg_input_file="$OPTARG"
			   ;;
        h)
            usage && exit 0
            ;;
        t)
            arg_tests=true
            ;;
        *)
            usage && exit 41
	         ;;
	 esac
done

shift $((OPTIND - 1))
# init switch flags

declare -g run_id run all fails

reset_run_id () {
    run_id="${EPOCHSECONDS}.$RANDOM$RANDOM"
    run="run.$run_id"
    all="$run/all"
    fails="$run/fails"

    mkdir "$run"
    touch "$all" "$fails"
}

reset_run_id

generate () {

    cat - <<eof
Picard =Nerys
Riker -Picard
Kirk -Spock
Spock -Kirk
Sisko -Nerys -Worf -O'Brien
Janeway -Kirk -Picard -Sisko -Spock -Riker -T'Pol -O'Brien -Worf -LaForge
Chakotay -Janeway
T'Pol
O'Brien
Worf =Picard
LaForge
eof
    
}

checks () {

    num_matches="$(cat "$run"/*."$match" | wc -l)"
    num_uniq_matches="$(cat "$run"/*."$match" | sort -u | wc -l)"

    if [ $num_matches -ne $num_uniq_matches ]; then
        echo "matches ($num_matches) != unique matches ($num_uniq_matches"
    fi

    while read -r each_participant; do
        num_times_matched="$(cat "$run"/*."$match" | grep -F "$each_participant" | wc -l)"
        if [ $num_times_matched -ne 1 ] ; then
            echo "$each_participant matched $num_times_matched times" >> $fails
        fi
    done < $all
    
    return [ -s $fails ]
}

match () {
   while [ $# -gt 0 ] ; do
       candidates_for "$1" | shuf | head -n 1 >> "$all/$1.match"
       num_matches="$( wc -l < $all.$1.match  )"
       
       if [ $num_matches -ne 1 ] ; then
           echo "$1 has $num_matches matches" >> "$fails"
           # return 1
       fi
       shift
   done

   return 0
}

run_tests () {

    generate  \
        | setup_data

    cat $all | match
    
    checks
                  
}

candidates_for () {
    [ $# -eq 1 ] || die
    
    cat "$all" \
        | grep -vF "$1" \
        | grep -vFf "$1.exclusions" \
        | grep -vFf <( cat $run/*.match )
}

setup_data () {

    while read -r linestring; do
        readarray line <<< "$linestring"

        [ ${#line} -gt 0 ] && this_part="${line[0]}" && echo "$this_part" >> "$all"

        touch $run/$this_part.match $run/$this_part.exclusions
        
        for item in "${line[@]}"; do
            if [[ $item =~ -(.*)$ ]]; then
                echo "${BASH_REMATCH[1]}" >> $run/$this_part.exclusions
            elif [[ $item =~ =(.*)$ ]]; then
                echo "${BASH_REMATCH[1]}" >> "$run/$this_part.$match"
            else            
                [[ "$item" != "$this_part" ]] && warn "Incorrect specification for $this_part: not sure what to do with $item"
            fi
        done
    done
}

if [[ "$0" == "${BASH_SOURCE[0]}" ]]; then

    [ -n "$arg_input_file" ] \
        && info "using input file $arg_input_file" \
        && "$0" < "$arg_input_file" \
        && exit $?
    
    [ -n "$arg_generate_file" ] \
        && "$0" -g > "$participants" \
        && exit $?

    [ -n "$arg_generate_stdout" ] \
        && generate \
        && exit $?

    [ -n "$arg_tests" ] && run_tests && exit $?

    cat - | setup_data || die

    make_matches || die

    for i in {1..100}; do
        if checks; then
            cd "$run"
            for d in *.assigned; do
                printf '%-15s: %s' "$d" $(cat "$d")
            done
            exit 0
        else
            thinbanner next run
            set_run_id
            make_matches || die
        fi
    done


else
    echo "Happy debugging!"
fi


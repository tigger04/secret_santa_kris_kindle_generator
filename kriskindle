#!/usr/bin/env bash

#shellcheck source=helper.sh
source helper.sh

set -e
unset arg_generate_stdout arg_generate_file arg_input_file arg_tests

function usage {
	 cat <<eom
    Usage: $(basename "$0") [OPTION]...

    -g         generate example input
    -G         generate example input to file 
    -i <FILE>  location of input file [default: STDIN]
    -h         display help
eom

}

while getopts "Ggi:ht" optKey; do
	 case "$optKey" in
        g)
            arg_generate_stdout=true
            ;;
		  G)
			   arg_generate_file=true
			   ;;
		  i)
            arg_input_file="$OPTARG"
			   ;;
        h)
            usage && exit 0
            ;;
        t)
            arg_tests=true
            ;;
        *)
            usage && exit 41
	         ;;
	 esac
done

shift $((OPTIND - 1))
# init switch flags
run_id="${EPOCHSECONDS}.$RANDOM$RANDOM"
participants="participants.$run_id"
exclusions="exclusions"
assignments="assignments"
candidates="candidates"
assigned="$participants/assigned"
all="$participants/all"

generate () {

    cat - <<eof
Picard =Nerys
Riker -Picard
Kirk -Spock
Spock -Kirk
Sisko -Nerys -Worf -O'Brien
Janeway -Chakotay -Kirk -Picard -Sisko
Chakotay -Janeway
T'Pol
O'Brien
Worf =Picard
"La Forge"
eof
    
}

get_participants () {

    grep -Po '^[^ ]+' < "$input"
    
}

get_fixes () {
    :
}

get_exclusions () {
    grep 
}

checks () {

    fail=0

    num_assignments="$(cat "$participants"/*."$assignments" | wc -l)"
    num_uniq_ass="$(cat "$participants"/*."$assignments" | sort -u | wc -l)"

    if [ $num_assignments -eq $num_uniq_ass ]; then
        info "uniq test pass"
    else
        fail=$((fail+1))
    fi

    matchtest1=$(mktemp)
    matchtest2=$(mktemp)
    cat "$participants"/*."$assignments" | sort -u > $matchtest1
    cat "$assigned" | sort -u > $matchtest2

    diff $matchtest1 $matchtest2 || fail=$((fail + 1))

    for p in "$all"; do
        recMatchesAgg="$( grep -F "$line" < "$assigned" | wc -l)"
        recMatchesFiles="$( cat "$participants"/*."$assigned" | grep -F "$line" | wc -l )"
             
        return $fail
}

make_matches () {

    cat "$all" | while read -r line; do
        p="$participants/$line"

        shuf "$p.candidates" \
            | grep -vFf "$assigned" \
            | shuf \
            | head -n 1 \
            | tee -a "$assigned" >> "$p.assignments"
    done
}



run_tests () {

    generate | setup_data && setup_candidates || die

    make_matches || die

    checks
        
}

setup_candidates () {

    touch "$assigned" || die

    cat "$all" | while read -r part; do

        cat "$all" \
            | grep -vF "$part" \
            | grep -vFf "$participants/$part.$exclusions" \
            | grep -vFf "$assigned" \
                   >> "$participants/$part.$candidates"
    done
}

assign () {
    [ $# -eq 2 ] || die

    assfile="$participants/$1.$assignments"

    if [ $(wc -c < "$assfile") -gt 0 ]; then
        warn "$1 is already assigned to $( <"$assfile" ), adding $2"
    fi
    
    echo "$2" >> "$assfile"
    echo "$2" >> "assigned"
}

setup_data () {
    #  get_participants > $participants

    mkdir $participants || die

    while read -r linestring; do
        line=($linestring)

        [ ${#line} -gt 0 ] && this_part="${line[0]}" && echo "$this_part" >> "$all"

        touch "$participants/$this_part.assignments" "$participants/$this_part.$exclusions" "$participants/$this_part.$candidates"
        
        for item in "${line[@]}"; do
            if [[ $item =~ -(.*)$ ]]; then
                echo "${BASH_REMATCH[1]}" >> "$participants/$this_part.$exclusions"
            elif [[ $item =~ =(.*)$ ]]; then
                echo "${BASH_REMATCH[1]}" >> "$participants/$this_part.$assignments"
            else            
                [[ "$item" != "$this_part" ]] && warn "Incorrect specification for $this_part: not sure what to do with $item"
            fi
        done
    done
}

    if [[ "$0" == "${BASH_SOURCE[0]}" ]]; then
        checks || die

        [ -n "$arg_input_file" ] \
            && info "using input file $arg_input_file" \
            && "$0" < "$arg_input_file" \
            && exit $?
        
        [ -n "$arg_generate_file" ] \
            && "$0" -g > "$participants" \
            && exit $?

        [ -n "$arg_generate_stdout" ] \
            && generate \
            && exit $?

        [ -n "$arg_tests" ] && run_tests && exit $?

        cat - | setup_data && setup_candidates || die

        make_matches || die

        checks


    else
        echo "Happy debugging!"
    fi


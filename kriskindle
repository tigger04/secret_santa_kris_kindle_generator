#!/usr/bin/env bash

#shellcheck source=~/bin/helper.sh
. ~/bin/helper.sh

set -e
declare -g run_id run all fails logfile iteration 
max_iterations=1000
iteration=0
unset arg_generate_stdout arg_generate_file arg_tests arg_input_file input_file 

logfile="$0.log"
verbose_output_to="$logfile"
timestamp begin >> "$logfile"

function usage {
	 cat <<eom
    Usage: $(basename "$0") [OPTION]...

    -g         generate example input
    -i <FILE>  location of input file [default: STDIN]
    -m <NUM>   maximum number of randomized iterations
    -h         display help
eom

}

while getopts "Ggi:ht" optKey; do
	 case "$optKey" in
        g)
            arg_generate_stdout=true
            ;;
		  G)
			   arg_generate_file=true
			   ;;
		  i)
            arg_input_file="$OPTARG"
			   ;;
        h)
            usage && exit 0
            ;;
        t)
            arg_tests=true
            ;;
        m)
            max_iterations="$OPTARG"
            ;;
        *)
            usage && exit 41
	         ;;
	 esac
done

shift $((OPTIND - 1))
# init switch flags

verbose declare -p arg_generate_stdout arg_generate_file arg_input_file arg_tests max_iterations


reset_run_id () {
    now="${EPOCHSECONDS}"
    run_id="${now}.$RANDOM$RANDOM"
    run="run.$run_id"
    all="$run/all"
    fails="$run/fails"
    
    mkdir "$run"
    touch "$all" "$fails" "$logfile"
}

reset_run_id

log () {

    logstring="$run_id ${FUNCNAME[1]} "

    if [[ "$1" == "verbose" ]] ; then
        shift
        verbose "$logstring $*"
    else    
        echo "$logstring $*" >> $logfile
    fi
}

fail () {
    fail_string="${FUNCNAME[1]}: $*"
    echo "$fail_string" >> $fails

    log "$fail_string"
}

generate () {

    cat - <<eof
Picard =Nerys
Riker -Picard
Kirk -Spock
Spock -Kirk
Sisko -Nerys -Worf -O'Brien
Janeway -Kirk -Picard -Sisko -Spock -Riker -T'Pol -O'Brien -Worf -LaForge
Chakotay -Janeway
T'Pol
O'Brien
Worf =Picard
LaForge
eof
    
}

checks () {

    [ $iteration -eq 0 ] && return 1

    num_matches="$(cat "$run"/*."match" | wc -l)"
    num_uniq_matches="$(cat "$run"/*."match" | sort -u | wc -l)"
    num_participants="$(cat $all | wc -l)"

    if [ $num_matches -ne $num_uniq_matches ]; then
        fail "matches ($num_matches) != unique matches ($num_uniq_matches)"
    fi

    if [ $num_matches -ne $num_participants ]; then
        fail "matches ($num_matches) != number of participants ($num_participants)"
    fi

    while read -r each_participant; do
        num_times_matched="$(cat "$run"/*."match" | grep -F "$each_participant" | wc -l)"
        if [ $num_times_matched -ne 1 ] ; then
            fail "$each_participant matched $((num_times_matched)) times"
        fi
    done < $all

    diff <( cat $all | sort ) <( cat $run/*.match | sort ) 2>&1 >/dev/null || fail "the list of particpants in $all does not match the list of particpants matched in $run/*.match"
    
    [ -s $fails ] && return 1
}

match () {

    cat - | while read -r participant; do
        log verbose "candidates for $participant: $(candidates_for "$participant")"
        candidates_for "$participant" | shuf | head -n 1 >> "$run/$participant.match"
        log verbose "chose: $(cat "$run/$participant.match")"
        num_matches="$( wc -l < $run/$participant.match  )"
        
        if [ $num_matches -ne 1 ] ; then
            fail "$participant has $((num_matches)) matches"
            # return 1
        fi
    done

    return 0
}

run_tests () {

    # echo > "$logfile"
    "$0" -g | "$0" -d
}

candidates_for () {
    [ $# -eq 1 ] || die
    
    cat "$all" \
        | grep -vF "$1" \
        | grep -vFf "$run/$1.exclusions" \
        | grep -vFf "$run/$1.match" \
        | grep -vFf <( cat $run/*.match )
}

setup_data () {

    while read -r linestring; do
        line=( $linestring )
        verbose declare -p line

        [ ${#line} -gt 0 ] && this_part="${line[0]}" && echo "$this_part" >> "$all"

        touch $run/$this_part.match $run/$this_part.exclusions
        
        for item in "${line[@]}"; do
            if [[ $item =~ -(.*)$ ]]; then
                echo "${BASH_REMATCH[1]}" >> $run/$this_part.exclusions
            elif [[ $item =~ =(.*)$ ]]; then
                echo "${BASH_REMATCH[1]}" >> "$run/$this_part.match"
            else            
                [[ "$item" != "$this_part" ]] && warn "Incorrect specification for $this_part: not sure what to do with $item"
            fi
        done
    done
}


finally () {
    timestamp end >> $logfile
}

if [[ "$0" == "${BASH_SOURCE[0]}" ]]; then

    if [ -n "$arg_tests" ]; then
        run_tests
        exit $?
    fi
    
    if [ -n "$arg_generate_stdout" ]; then
        generate
        exit $?
    fi

    log checking input file
    verbose declare -p log_input_file
    
    if ! [ -n "$arg_input_file" ]; then
        input_file=$(mktemp)
        input_file_descriptor=STDIN
        verbose declare -p input_file input_file_descriptor
        cat - > $input_file
        verbose $(cat "$input_file")
        
    else
        input_file="$arg_input_file"
        input_file_descriptor="$(nice_path "$input_file")"
    fi

    num_records="$(wc -l < "$input_file")"
    num_records=$(( num_records )) # to lose the whitespace for display
    info "read ${bold}$((num_records))${bold_off} records from ${bold}${input_file_descriptor}${bold_off}"

    iterate () {
        reset_run_id
        cat "$input_file" | setup_data
        cat $all | match
        iteration=$((iteration + 1))
    }

    while ! checks && [ $iteration -le $max_iterations ]; do
        iterate
    done

    if [ -s $fails ] ; then
        errortext "Could not match all participants in $max_iterations randomized iterations, please check your constraints"
    else
        
        info "$command_base has made the following randomized matches"

        echo -ne "$bigreen"

        cat $all | while read -r part; do
            printf '%-15s ➡️ %s' \
                   "$part" \
                   "$(cat "$run/$part.match")"
        done

        echo -ne "$ansi_off"
    fi

else
    echo "Happy debugging!"
fi
